// SPDX-FileCopyrightText: (C) 2026 Intel Corporation
// SPDX-License-Identifier: Apache-2.0

package main

import (
	"bytes"
	"flag"
	"fmt"
	"go/format"
	"io/fs"
	"log"
	"os"
	"path/filepath"
	"regexp"
	"sort"
	"strings"

	"gopkg.in/yaml.v3"
)

type Manifest struct {
	Services []string `yaml:"services"`
}

func main() {
	var (
		manifestsDir = flag.String("manifests", "manifests", "Directory containing scenario YAML manifests")
		outFile      = flag.String("out", "internal/scenario/allowlist_gen.go", "Output Go file to generate")
		pkgName      = flag.String("pkg", "scenario", "Package name for generated file")
	)
	flag.Parse()

	allow, err := loadAllManifests(*manifestsDir)
	if err != nil {
		log.Printf("failed to load manifests: %v", err)
		os.Exit(1)
	}

	// Validate services against server implementation
	if err := validateServices(allow); err != nil {
		log.Printf("validation failed: %v", err)
		os.Exit(1)
	}

	if err := writeGenerated(*outFile, *pkgName, allow); err != nil {
		log.Printf("failed to write generated file: %v", err)
		os.Exit(1)
	}

	log.Printf("generated %s from %s", *outFile, *manifestsDir)
}

func loadAllManifests(dir string) (map[string][]string, error) {
	out := make(map[string][]string)

	err := filepath.WalkDir(dir, func(path string, d fs.DirEntry, walkErr error) error {
		if walkErr != nil {
			return walkErr
		}
		return processManifestFile(path, d, out)
	})
	if err != nil {
		return nil, err
	}
	if len(out) == 0 {
		return nil, fmt.Errorf("no manifests found under %q", dir)
	}
	return out, nil
}

// processManifestFile processes a single manifest file
func processManifestFile(path string, d fs.DirEntry, out map[string][]string) error {
	if d.IsDir() {
		return nil
	}

	if !strings.HasSuffix(d.Name(), ".yaml") && !strings.HasSuffix(d.Name(), ".yml") {
		return nil
	}

	// Extract scenario name from filename
	scenario := strings.TrimSuffix(d.Name(), filepath.Ext(d.Name()))
	scenario = strings.ToLower(strings.TrimSpace(scenario))
	if scenario == "" {
		return fmt.Errorf("invalid manifest filename: %s", d.Name())
	}

	// Read and parse the manifest file
	b, err := os.ReadFile(path)
	if err != nil {
		return fmt.Errorf("read %s: %w", path, err)
	}

	var m Manifest
	if err := yaml.Unmarshal(b, &m); err != nil {
		return fmt.Errorf("parse file %s error: %w", path, err)
	}

	// Validate and clean services list
	services := clean(m.Services)
	if len(services) == 0 {
		return fmt.Errorf("%s: services list is empty", path)
	}

	out[scenario] = services
	return nil
}

func clean(in []string) []string {
	seen := map[string]struct{}{}
	out := make([]string, 0, len(in))

	for _, s := range in {
		s = strings.TrimSpace(s)
		if s == "" {
			continue
		}

		// Skip duplicates
		if _, ok := seen[s]; ok {
			continue
		}
		seen[s] = struct{}{}
		out = append(out, s)
	}

	return out
}

func writeGenerated(outPath, pkg string, allowed map[string][]string) error {
	scenarios := make([]string, 0, len(allowed))
	for sc := range allowed {
		scenarios = append(scenarios, sc)
	}
	sort.Strings(scenarios)

	var buf bytes.Buffer
	buf.WriteString("// SPDX-FileCopyrightText: (C) 2026 Intel Corporation\n")
	buf.WriteString("// SPDX-" + "License-Identifier: Apache-2.0\n")
	buf.WriteString("\n")
	buf.WriteString("// Code generated by tools/allowedservicesgen; DO NOT EDIT.\n")
	buf.WriteString("package " + pkg + "\n\n")

	buf.WriteString("var KnownScenarios = []string{\n")
	for _, sc := range scenarios {
		buf.WriteString(fmt.Sprintf("\t%q,\n", sc))
	}
	buf.WriteString("}\n\n")

	buf.WriteString("var Allowlist = map[string][]string{\n")
	for _, sc := range scenarios {
		services := append([]string(nil), allowed[sc]...)
		sort.Strings(services)

		buf.WriteString(fmt.Sprintf("\t%q: {\n", sc))
		for _, s := range services {
			buf.WriteString(fmt.Sprintf("\t\t%q,\n", s))
		}
		buf.WriteString("\t},\n")
	}
	buf.WriteString("}\n")

	// gofmt the output for readability
	formatted, err := format.Source(buf.Bytes())
	if err != nil {
		// If formatting fails, still write the raw code but leave a warning
		if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
			return fmt.Errorf("mkdir: %w", err)
		}
		if err := os.WriteFile(outPath, buf.Bytes(), 0o644); err != nil {
			return fmt.Errorf("write (unformatted): %w", err)
		}
		log.Printf("Warning: gofmt failed on generated code, wrote unformatted version")
		return nil
	}

	// Write formatted code
	if err := os.MkdirAll(filepath.Dir(outPath), 0o755); err != nil {
		return fmt.Errorf("mkdir: %w", err)
	}
	if err := os.WriteFile(outPath, formatted, 0o644); err != nil {
		return fmt.Errorf("write: %w", err)
	}
	return nil
}

// getServicesFromProto parses the proto file and extracts service names.
func getServicesFromProto(protoPath string) (map[string]struct{}, int, error) {
	content, err := os.ReadFile(protoPath)
	if err != nil {
		return nil, 0, fmt.Errorf("read proto file %q: %w", protoPath, err)
	}

	// Matches: service HostService {  OR  service Host {
	re := regexp.MustCompile(`(?m)^service\s+(\w+)\s*\{`)
	matches := re.FindAllSubmatch(content, -1)

	services := make(map[string]struct{})

	for _, match := range matches {
		if len(match) < 2 {
			continue
		}

		rawName := string(match[1])
		normalized := normalizeServiceName(rawName)

		services[normalized] = struct{}{}
	}

	return services, len(services), nil
}

func normalizeServiceName(name string) string {
	const suffix = "Service"

	if strings.HasSuffix(name, suffix) {
		return strings.TrimSuffix(name, suffix)
	}
	return name
}

// validateServices checks that all services in manifests are defined in proto file.
func validateServices(allowed map[string][]string) error {
	// Get services from proto file (source of truth)
	protoServicesMap, serviceCount, err := getServicesFromProto("api/proto/services/v1/services.proto")
	if err != nil {
		return fmt.Errorf("failed to parse proto: %w", err)
	}

	log.Printf("found %d service(s) in proto file", serviceCount)

	// Collect all unique services from manifests
	manifestServices := make(map[string]bool)
	for scenario, services := range allowed {
		for _, svc := range services {
			normalized := normalizeServiceName(svc)
			manifestServices[normalized] = true
		}
		log.Printf("scenario %q: %d service(s)", scenario, len(services))
	}

	// Validate each manifest service exists in proto
	var missing []string
	for svc := range manifestServices {
		if _, ok := protoServicesMap[svc]; !ok {
			missing = append(missing, svc)
		}
	}

	if len(missing) > 0 {
		sort.Strings(missing)
		return fmt.Errorf("services in manifests but not defined in proto: %v", missing)
	}

	log.Printf("validation passed")
	return nil
}
