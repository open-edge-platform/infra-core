// SPDX-FileCopyrightText: (C) 2025 Intel Corporation
// SPDX-License-Identifier: Apache-2.0
// Code generated by "gen", DO NOT EDIT.

package cli


import (
	"context"
	"errors"
	//"flag"
	"fmt"
	//"os"
	//"os/signal"
	//"strings"
	//"sync"
	//"syscall"

	"github.com/manifoldco/promptui"
	"google.golang.org/protobuf/encoding/prototext"

	computev1 "github.com/open-edge-platform/infra-core/inventory/v2/pkg/api/compute/v1"
	locationv1 "github.com/open-edge-platform/infra-core/inventory/v2/pkg/api/location/v1"
	inv_v1 "github.com/open-edge-platform/infra-core/inventory/v2/pkg/api/inventory/v1"
	inv_client "github.com/open-edge-platform/infra-core/inventory/v2/pkg/client"
	inv_errors "github.com/open-edge-platform/infra-core/inventory/v2/pkg/errors"
	inv_util "github.com/open-edge-platform/infra-core/inventory/v2/pkg/util"
)

// Helper funcs for Host
func helperListHosts(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.HostResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.HostResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.HostResource](resp)
}

func (c *Cli) PromptListHosts(interface{}) (interface{}, error) {
	for {
		res, err := helperListHosts(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptHostDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d Hosts total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptHostDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.HostResource)
		if !ok {
			return nil, errors.New("not a Host")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteHost, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "Host Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteHost(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.HostResource)
	if !ok {
		return nil, errors.New("not a Host")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm Host deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for HostNic
func helperListHostNics(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.HostnicResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.HostnicResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.HostnicResource](resp)
}

func (c *Cli) PromptListHostNics(interface{}) (interface{}, error) {
	for {
		res, err := helperListHostNics(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptHostNicDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d HostNics total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptHostNicDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.HostnicResource)
		if !ok {
			return nil, errors.New("not a HostNic")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteHostNic, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "HostNic Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteHostNic(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.HostnicResource)
	if !ok {
		return nil, errors.New("not a HostNic")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm HostNic deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for HostStorage
func helperListHostStorages(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.HoststorageResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.HoststorageResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.HoststorageResource](resp)
}

func (c *Cli) PromptListHostStorages(interface{}) (interface{}, error) {
	for {
		res, err := helperListHostStorages(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptHostStorageDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d HostStorages total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptHostStorageDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.HoststorageResource)
		if !ok {
			return nil, errors.New("not a HostStorage")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteHostStorage, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "HostStorage Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteHostStorage(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.HoststorageResource)
	if !ok {
		return nil, errors.New("not a HostStorage")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm HostStorage deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for HostUSB
func helperListHostUSBs(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.HostusbResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.HostusbResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.HostusbResource](resp)
}

func (c *Cli) PromptListHostUSBs(interface{}) (interface{}, error) {
	for {
		res, err := helperListHostUSBs(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptHostUSBDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d HostUSBs total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptHostUSBDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.HostusbResource)
		if !ok {
			return nil, errors.New("not a HostUSB")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteHostUSB, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "HostUSB Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteHostUSB(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.HostusbResource)
	if !ok {
		return nil, errors.New("not a HostUSB")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm HostUSB deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for Instance
func helperListInstances(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.InstanceResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.InstanceResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.InstanceResource](resp)
}

func (c *Cli) PromptListInstances(interface{}) (interface{}, error) {
	for {
		res, err := helperListInstances(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptInstanceDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d Instances total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptInstanceDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.InstanceResource)
		if !ok {
			return nil, errors.New("not a Instance")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteInstance, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "Instance Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteInstance(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.InstanceResource)
	if !ok {
		return nil, errors.New("not a Instance")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm Instance deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for Workload
func helperListWorkloads(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.WorkloadResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.WorkloadResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.WorkloadResource](resp)
}

func (c *Cli) PromptListWorkloads(interface{}) (interface{}, error) {
	for {
		res, err := helperListWorkloads(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptWorkloadDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d Workloads total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptWorkloadDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.WorkloadResource)
		if !ok {
			return nil, errors.New("not a Workload")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteWorkload, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "Workload Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteWorkload(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.WorkloadResource)
	if !ok {
		return nil, errors.New("not a Workload")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm Workload deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for WorkloadMember
func helperListWorkloadMembers(ctx context.Context, client inv_client.InventoryClient) ([]*computev1.WorkloadMember, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&computev1.WorkloadMember{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*computev1.WorkloadMember](resp)
}

func (c *Cli) PromptListWorkloadMembers(interface{}) (interface{}, error) {
	for {
		res, err := helperListWorkloadMembers(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptWorkloadMemberDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d WorkloadMembers total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptWorkloadMemberDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*computev1.WorkloadMember)
		if !ok {
			return nil, errors.New("not a WorkloadMember")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteWorkloadMember, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "WorkloadMember Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteWorkloadMember(arg interface{}) (interface{}, error) {
	r, ok := arg.(*computev1.WorkloadMember)
	if !ok {
		return nil, errors.New("not a WorkloadMember")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm WorkloadMember deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for Region
func helperListRegions(ctx context.Context, client inv_client.InventoryClient) ([]*locationv1.RegionResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&locationv1.RegionResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*locationv1.RegionResource](resp)
}

func (c *Cli) PromptListRegions(interface{}) (interface{}, error) {
	for {
		res, err := helperListRegions(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptRegionDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d Regions total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptRegionDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*locationv1.RegionResource)
		if !ok {
			return nil, errors.New("not a Region")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteRegion, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "Region Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteRegion(arg interface{}) (interface{}, error) {
	r, ok := arg.(*locationv1.RegionResource)
	if !ok {
		return nil, errors.New("not a Region")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm Region deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}

// Helper funcs for Site
func helperListSites(ctx context.Context, client inv_client.InventoryClient) ([]*locationv1.SiteResource, error) {
	kind, err := inv_util.GetResourceKindFromMessage(&locationv1.SiteResource{})
	if err != nil {
		return nil, err
	}
	res, err := inv_util.GetResourceFromKind(kind)
	if err != nil {
		return nil, err
	}
	filter := &inv_v1.ResourceFilter{
		Resource:  res,
	}
	resp, err := client.ListAll(ctx, filter)
	if inv_errors.IsNotFound(err) {
		// Continue with empty list.
	} else if err != nil {
		return nil, err
	}
	return inv_util.GetSpecificResourceList[*locationv1.SiteResource](resp)
}

func (c *Cli) PromptListSites(interface{}) (interface{}, error) {
	for {
		res, err := helperListSites(c.ctx, c.client)
		if err != nil {
			return nil, err
		}
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt},
		}
		for _, r := range res {
			items = append(items, menuItem{
				Name: fmt.Sprintf("%.*s", c.lineItemMaxWidth, r),
				Next: c.PromptSiteDetails,
				Arg:  r,
			})
		}
		prompt := promptui.Select{
			Label:     fmt.Sprintf("%d Sites total:", len(res)),
			Items:     items,
			Templates: selectTemplate,
			Size:      6,
			Searcher:  stringContainSearcher(items),
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptSiteDetails(arg interface{}) (interface{}, error) {
	for {
		r, ok := arg.(*locationv1.SiteResource)
		if !ok {
			return nil, errors.New("not a Site")
		}
		fmt.Printf("%s", prototext.MarshalOptions{Multiline: true}.Format(r))
		items := []menuItem{
			{Name: labelBack, Next: parentPrompt, Arg: r},
			{Name: "<Select>", Next: returnSelectedItem, Arg: r},
			{Name: "<Delete>", Next: c.PromptDeleteSite, Arg: r},
		}
		prompt := promptui.Select{
			Label:     "Site Actions:",
			Items:     items,
			Templates: selectTemplate,
			Size:      15,
		}
		i, _, err := prompt.Run()
		if err != nil {
			fmt.Printf("Prompt failed %v\n", err)
			return nil, err
		}
		arg, err := items[i].Next(items[i].Arg)
		if errors.Is(err, errPromptDone) {
			return arg, nil
		} else if errors.Is(err, errPromptSelectDone) {
			return arg, err
		} else if err != nil {
			return nil, err
		}
	}
}

func (c *Cli) PromptDeleteSite(arg interface{}) (interface{}, error) {
	r, ok := arg.(*locationv1.SiteResource)
	if !ok {
		return nil, errors.New("not a Site")
	}
	prompt := promptui.Prompt{
		Label:     "Confirm Site deletion:",
		IsConfirm: true,
	}
	for {
		result, err := prompt.Run()
		if err != nil {
			return nil, nil
		}
		if result != "y" {
			return nil, nil
		}
		_, err = c.client.Delete(c.ctx, r.GetResourceId())
		return nil, err
	}
}
