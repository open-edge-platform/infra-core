# Generated by the protocol buffer compiler.  DO NOT EDIT!
# sources: inventory/v1/inventory.proto
# plugin: python-betterproto
from dataclasses import dataclass
from typing import AsyncGenerator, List, Optional

import betterproto
import grpclib

from .compute import v1
from .google import protobuf
from .localaccount import v1
from .location import v1
from .network import v1
from .os import v1
from .ou import v1
from .provider import v1
from .remoteaccess import v1
from .schedule import v1
from .telemetry import v1
from .tenant import v1


class ClientKind(betterproto.Enum):
    CLIENT_KIND_UNSPECIFIED = 0
    CLIENT_KIND_API = 1
    CLIENT_KIND_RESOURCE_MANAGER = 2
    CLIENT_KIND_TENANT_CONTROLLER = 3


class ResourceKind(betterproto.Enum):
    RESOURCE_KIND_UNSPECIFIED = 0
    RESOURCE_KIND_REGION = 8
    RESOURCE_KIND_SITE = 9
    RESOURCE_KIND_OU = 10
    RESOURCE_KIND_PROVIDER = 32
    RESOURCE_KIND_HOST = 48
    RESOURCE_KIND_HOSTSTORAGE = 49
    RESOURCE_KIND_HOSTNIC = 50
    RESOURCE_KIND_HOSTUSB = 51
    RESOURCE_KIND_HOSTGPU = 52
    RESOURCE_KIND_INSTANCE = 64
    RESOURCE_KIND_IPADDRESS = 95
    RESOURCE_KIND_NETWORKSEGMENT = 96
    RESOURCE_KIND_NETLINK = 97
    RESOURCE_KIND_ENDPOINT = 98
    RESOURCE_KIND_OS = 99
    RESOURCE_KIND_SINGLESCHEDULE = 100
    RESOURCE_KIND_REPEATEDSCHEDULE = 101
    RESOURCE_KIND_WORKLOAD = 110
    RESOURCE_KIND_WORKLOAD_MEMBER = 111
    RESOURCE_KIND_TELEMETRY_GROUP = 120
    RESOURCE_KIND_TELEMETRY_PROFILE = 121
    RESOURCE_KIND_TENANT = 130
    RESOURCE_KIND_RMT_ACCESS_CONF = 150
    RESOURCE_KIND_LOCALACCOUNT = 170
    RESOURCE_KIND_OSUPDATEPOLICY = 180
    RESOURCE_KIND_OSUPDATERUN = 190


class SubscribeEventsResponseEventKind(betterproto.Enum):
    EVENT_KIND_UNSPECIFIED = 0
    EVENT_KIND_CREATED = 1
    EVENT_KIND_UPDATED = 2
    EVENT_KIND_DELETED = 3


@dataclass
class SubscribeEventsRequest(betterproto.Message):
    # The name of the API client
    name: str = betterproto.string_field(1)
    # version string of the Client
    version: str = betterproto.string_field(2)
    # the kind of API client
    client_kind: "ClientKind" = betterproto.enum_field(3)
    # The resource kinds that this client provides or subscribes to. Can be empty
    # to not receive any events.
    subscribed_resource_kinds: List["ResourceKind"] = betterproto.enum_field(4)


@dataclass
class SubscribeEventsResponse(betterproto.Message):
    # For the first event response sent to the client, a UUID will be generated
    # and assigned to that client. Subsequent requests must use this UUID.
    client_uuid: str = betterproto.string_field(1)
    # Deprecated, use resource instead. The resource ID that was changed.
    resource_id: str = betterproto.string_field(2)
    # The changed resource. On delete events this contains the last known state.
    # On create and update events this contains the new state.
    resource: "Resource" = betterproto.message_field(3)
    event_kind: "SubscribeEventsResponseEventKind" = betterproto.enum_field(4)


@dataclass
class ChangeSubscribeEventsRequest(betterproto.Message):
    # The UUID of the client to change the subscriptions for.
    client_uuid: str = betterproto.string_field(1)
    # The new resource kinds that the client subscribes to. Can be empty to not
    # receive any events. Replaces the current subscriptions.
    subscribed_resource_kinds: List["ResourceKind"] = betterproto.enum_field(4)


@dataclass
class ChangeSubscribeEventsResponse(betterproto.Message):
    pass


@dataclass
class CreateResourceRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    resource: "Resource" = betterproto.message_field(3)
    # Definition of tenant_id can be seen as redundant since tenant_id is also
    # defined in the nested resource. Extracting tenant information from nested
    # structs could be expensive. Tenant related requests handling strategy has
    # been created based on convention assuming that tenant is available on top
    # level of requests, this approach comes with clarity of implementation.
    # Underlying implementation enforces that tenant_id is consistent with
    # tenant_id provided in the nested resource.
    tenant_id: str = betterproto.string_field(100)


@dataclass
class Resource(betterproto.Message):
    region: v1.RegionResource = betterproto.message_field(1, group="resource")
    site: v1.SiteResource = betterproto.message_field(2, group="resource")
    ou: v1.OuResource = betterproto.message_field(10, group="resource")
    provider: v1.ProviderResource = betterproto.message_field(30, group="resource")
    host: v1.HostResource = betterproto.message_field(40, group="resource")
    hoststorage: v1.HoststorageResource = betterproto.message_field(
        41, group="resource"
    )
    hostnic: v1.HostnicResource = betterproto.message_field(42, group="resource")
    hostusb: v1.HostusbResource = betterproto.message_field(43, group="resource")
    hostgpu: v1.HostgpuResource = betterproto.message_field(44, group="resource")
    instance: v1.InstanceResource = betterproto.message_field(50, group="resource")
    ipaddress: v1.IPAddressResource = betterproto.message_field(59, group="resource")
    network_segment: v1.NetworkSegment = betterproto.message_field(60, group="resource")
    netlink: v1.NetlinkResource = betterproto.message_field(61, group="resource")
    endpoint: v1.EndpointResource = betterproto.message_field(62, group="resource")
    os: v1.OperatingSystemResource = betterproto.message_field(70, group="resource")
    singleschedule: v1.SingleScheduleResource = betterproto.message_field(
        80, group="resource"
    )
    repeatedschedule: v1.RepeatedScheduleResource = betterproto.message_field(
        81, group="resource"
    )
    workload: v1.WorkloadResource = betterproto.message_field(90, group="resource")
    workload_member: v1.WorkloadMember = betterproto.message_field(91, group="resource")
    telemetry_group: v1.TelemetryGroupResource = betterproto.message_field(
        100, group="resource"
    )
    telemetry_profile: v1.TelemetryProfile = betterproto.message_field(
        101, group="resource"
    )
    tenant: v1.Tenant = betterproto.message_field(130, group="resource")
    remote_access: v1.RemoteAccessConfiguration = betterproto.message_field(
        150, group="resource"
    )
    local_account: v1.LocalAccountResource = betterproto.message_field(
        170, group="resource"
    )
    os_update_policy: v1.OSUpdatePolicyResource = betterproto.message_field(
        180, group="resource"
    )
    os_update_run: v1.OSUpdateRunResource = betterproto.message_field(
        190, group="resource"
    )


@dataclass
class ResourceFilter(betterproto.Message):
    """
    Filter resources with the given filter. The filter requires a filter string
    and a resource (kind) to be specified. Also, limit and offset parameter are
    used for pagination.
    """

    # The resource kind to filter on, must always be specified. Generally the
    # resource's fields are unset, except for metadata filters that include
    # inherited metadata.
    resource: "Resource" = betterproto.message_field(3)
    limit: int = betterproto.uint32_field(512)
    offset: int = betterproto.uint32_field(513)
    # Optional filter to return only resources of interest. See
    # https://google.aip.dev/160 for details. Note: for backwards compatability
    # the fields `field_mask` and `resource` are used for filtering when `filter`
    # is unset. This means an empty (=no) filter cannot be expressed at the
    # moment. Clients wanting to use this filter mechanism must set `filter` and
    # `resource` to select which resource type to return. Calls with an invalid
    # filter will fail with `INVALID_ARGUMENT`. Limitations:  - Timestamps are
    # not supported beyond treating them as simple strings.  - Filtering with
    # only a naked literal (`filter: "foo"`) is not supported. Always provide a
    # field.  - Field names must be given as they appear in the protobuf message,
    # but see the notes on casing.  - The ":" (has) operator is not supported.
    # Use the `has(<edge name>)` function extension instead.  - Nested fields may
    # be accessed up to 5 levels deep. I.e. `site.region.name = "foo"`.  - If a
    # string literal contains double quotes, the string itself must be single
    # quoted. I.e. `metadata = '{"key": "value"}'` Extensions:  - All fields of
    # the resource kind set in `resource` are hoisted into the global name space.
    # I.e. can be accessed    directly without prefixing: `resource_id =
    # "host-1234"` instead of `host.resource_id = ...`.  - Field names may be
    # specified in both camelCase and snake_case.  - To check for edge presence,
    # use the `has(<edge_name>)` operator. E.g.: `has(site)` to filter by
    # resources that    are linked to a site. Can be used on nested edges:
    # `has(site.region)`.  - String equality comparisons are case insensitive.
    # `name = "foo"` and `name = "FOO"` are equivalent.  - String equality
    # comparisons are fuzzy. `name = "abc"` will match `abc`, `abcd` and
    # `123abc`.  - String equality comparisons may contain one or multiple
    # wildcards `*` which match any number of characters.
    filter: str = betterproto.string_field(4)
    # Optional, comma-seperated list of fields that specify the sorting order of
    # the requested resources. By default, resources are returned in
    # alphanumerical and ascending order based on their resource ID. Fields can
    # be given in either their proto `foo_bar` and JSON `fooBar` casing. See
    # https://google.aip.dev/132 for details. Additional limitations: Ordering on
    # nested fields, such as `foo.bar` is not supported.
    order_by: str = betterproto.string_field(5)


@dataclass
class FindResourcesRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    filter: "ResourceFilter" = betterproto.message_field(2)


@dataclass
class FindResourcesResponse(betterproto.Message):
    resources: List["FindResourcesResponseResourceTenantIDCarrier"] = (
        betterproto.message_field(5)
    )
    # Deprecated. Use total_elements instead.
    has_next: bool = betterproto.bool_field(16)
    # Total number of items the find request would return, if not limited by
    # pagination. Callers can use this value to determine if there are more
    # elements to be fetched, by comparing the supplied offset and returned items
    # to the total: bool more = offset + len(resource_id) < total_elements
    total_elements: int = betterproto.int32_field(2)


@dataclass
class FindResourcesResponseResourceTenantIDCarrier(betterproto.Message):
    tenant_id: str = betterproto.string_field(1)
    resource_id: str = betterproto.string_field(2)


@dataclass
class ListResourcesRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    filter: "ResourceFilter" = betterproto.message_field(2)


@dataclass
class ListResourcesResponse(betterproto.Message):
    resources: List["GetResourceResponse"] = betterproto.message_field(1)
    # Deprecated. Use total_elements instead.
    has_next: bool = betterproto.bool_field(16)
    # Total number of items the list request would return, if not limited by
    # pagination. Callers can use this value to determine if there are more
    # elements to be fetched, by comparing the supplied offset and returned items
    # to the total: bool more = offset + len(resources) < total_elements
    total_elements: int = betterproto.int32_field(2)


@dataclass
class GetResourceRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    resource_id: str = betterproto.string_field(2)
    tenant_id: str = betterproto.string_field(100)


@dataclass
class GetResourceResponse(betterproto.Message):
    resource: "Resource" = betterproto.message_field(1)
    rendered_metadata: "GetResourceResponseResourceMetadata" = (
        betterproto.message_field(200)
    )


@dataclass
class GetResourceResponseResourceMetadata(betterproto.Message):
    """
    Contains the rendered metadata with format as json string. Example:
    [{"key":"cluster-name","value":""},{"key":"app-id","value":""}]
    """

    phy_metadata: str = betterproto.string_field(1)
    logi_metadata: str = betterproto.string_field(2)


@dataclass
class UpdateResourceRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    resource_id: str = betterproto.string_field(2)
    field_mask: protobuf.FieldMask = betterproto.message_field(3)
    resource: "Resource" = betterproto.message_field(4)
    # Definition of tenant_id can be seen as redundant since tenant_id is also
    # defined in the nested resource. Extracting tenant information from nested
    # structs could be expensive. Tenant related requests handling strategy has
    # been created based on convention assuming that tenant is available on top
    # level of requests, this approach comes with clarity of implementation.
    # Underlying implementation enforces that tenant_id is consistent with
    # tenant_id provided in the nested resource.
    tenant_id: str = betterproto.string_field(100)


@dataclass
class DeleteResourceRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    resource_id: str = betterproto.string_field(2)
    tenant_id: str = betterproto.string_field(100)


@dataclass
class DeleteResourceResponse(betterproto.Message):
    pass


@dataclass
class ListInheritedTelemetryProfilesRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    # Specifies the base resource ID to inherit from (Instance, Site, or Region
    # ID).
    inherit_by: "ListInheritedTelemetryProfilesRequestInheritBy" = (
        betterproto.message_field(10)
    )
    # Specify a filter on the inherited telemetry profiles. Allows also to
    # specify pagination parameters (these must always be set) Note: we support
    # ONLY the new `AIP-160`-style filter, so filter.fieldmask and
    # filter.resource are not supported
    filter: "ResourceFilter" = betterproto.message_field(15)
    # Definition of tenant_id can be seen as redundant since tenant_id is also
    # defined in the nested resource. Extracting tenant information from nested
    # structs could be expensive. Tenant related requests handling strategy has
    # been created based on convention assuming that tenant is available on top
    # level of requests, this approach comes with clarity of implementation.
    tenant_id: str = betterproto.string_field(100)


@dataclass
class ListInheritedTelemetryProfilesRequestInheritBy(betterproto.Message):
    instance_id: str = betterproto.string_field(1, group="id")
    site_id: str = betterproto.string_field(2, group="id")
    region_id: str = betterproto.string_field(3, group="id")


@dataclass
class ListInheritedTelemetryProfilesResponse(betterproto.Message):
    # The inherited Telemetry Profiles given the "inherit_by" param given in the
    # request
    telemetry_profiles: List[v1.TelemetryProfile] = betterproto.message_field(1)
    # Total number of Telemetry Profiles the request would return, if not limited
    # by pagination. Callers can use this value to determine if there are more
    # elements to be fetched, by comparing the supplied offset and returned items
    # to the total: bool more = offset + len(resource_id) < total_elements
    total_elements: int = betterproto.int32_field(10)


@dataclass
class GetTreeHierarchyRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    # List of resource ID to filter upon
    filter: List[str] = betterproto.string_field(10)
    # Order the tree by descending depth (root to leaf), otherwise ordering is by
    # ascending depth (leaf to root).
    descending: bool = betterproto.bool_field(15)
    # Definition of tenant_id can be seen as redundant since it could be provided
    # as part of nested filter. Extracting tenant information from nested structs
    # could be expensive. Tenant related requests handling strategy has been
    # created based on convention assuming that tenant is available on top level
    # of requests, this approach comes with clarity of implementation.
    tenant_id: str = betterproto.string_field(100)


@dataclass
class GetTreeHierarchyResponse(betterproto.Message):
    # Ordered list of tree nodes by depth
    tree: List["GetTreeHierarchyResponseTreeNode"] = betterproto.message_field(1)


@dataclass
class GetTreeHierarchyResponseNode(betterproto.Message):
    resource_id: str = betterproto.string_field(1)
    resource_kind: "ResourceKind" = betterproto.enum_field(2)


@dataclass
class GetTreeHierarchyResponseTreeNode(betterproto.Message):
    current_node: "GetTreeHierarchyResponseNode" = betterproto.message_field(1)
    parent_nodes: List["GetTreeHierarchyResponseNode"] = betterproto.message_field(2)
    # Name of the resource if available, otherwise unset
    name: str = betterproto.string_field(10)
    # The depth in the tree of the current node
    depth: int = betterproto.int32_field(11)


@dataclass
class GetSitesPerRegionRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    # List of resource ID to filter upon
    filter: List[str] = betterproto.string_field(10)
    # Definition of tenant_id can be seen as redundant since tenant_id is also
    # defined in the nested resource. Extracting tenant information from nested
    # structs could be expensive. Tenant related requests handling strategy has
    # been created based on convention assuming that tenant is available on top
    # level of requests, this approach comes with clarity of implementation.
    tenant_id: str = betterproto.string_field(100)


@dataclass
class GetSitesPerRegionResponse(betterproto.Message):
    # Ordered list of nodes
    regions: List["GetSitesPerRegionResponseNode"] = betterproto.message_field(1)


@dataclass
class GetSitesPerRegionResponseNode(betterproto.Message):
    resource_id: str = betterproto.string_field(1)
    child_sites: int = betterproto.int32_field(2)


@dataclass
class DeleteAllResourcesRequest(betterproto.Message):
    client_uuid: str = betterproto.string_field(1)
    resource_kind: "ResourceKind" = betterproto.enum_field(2)
    enforce: bool = betterproto.bool_field(3)
    tenant_id: str = betterproto.string_field(100)


@dataclass
class DeleteAllResourcesResponse(betterproto.Message):
    pass


class InventoryServiceStub(betterproto.ServiceStub):
    """
    Inventory Service (IS) provides an API for managing resources. Selected
    RPCs operates on tenant context, each of them specifies obligatory
    tenant_id field. Any RPC operations relying on request messages not
    specifying tenant_id are intended to operate cross-tenant.
    """

    async def subscribe_events(
        self,
        *,
        name: str = "",
        version: str = "",
        client_kind: "ClientKind" = 0,
        subscribed_resource_kinds: List["ResourceKind"] = [],
    ) -> AsyncGenerator[SubscribeEventsResponse, None]:
        """
        Registers a new client and subscribes to the requested events. All
        clients must open and maintain this stream before making any other
        requests. Closing this stream de-registers the client.
        """

        request = SubscribeEventsRequest()
        request.name = name
        request.version = version
        request.client_kind = client_kind
        request.subscribed_resource_kinds = subscribed_resource_kinds

        async for response in self._unary_stream(
            "/inventory.v1.InventoryService/SubscribeEvents",
            request,
            SubscribeEventsResponse,
        ):
            yield response

    async def change_subscribe_events(
        self,
        *,
        client_uuid: str = "",
        subscribed_resource_kinds: List["ResourceKind"] = [],
    ) -> ChangeSubscribeEventsResponse:
        """
        Changes the resource kinds the given client will receive events for.
        See SubscribeEvents.
        """

        request = ChangeSubscribeEventsRequest()
        request.client_uuid = client_uuid
        request.subscribed_resource_kinds = subscribed_resource_kinds

        return await self._unary_unary(
            "/inventory.v1.InventoryService/ChangeSubscribeEvents",
            request,
            ChangeSubscribeEventsResponse,
        )

    async def create_resource(
        self,
        *,
        client_uuid: str = "",
        resource: Optional["Resource"] = None,
        tenant_id: str = "",
    ) -> Resource:
        """
        Create a new resource, returning it (or error). Returns UNKNOWN_CLIENT
        error if the UUID is not known. See SubscribeEvents.
        """

        request = CreateResourceRequest()
        request.client_uuid = client_uuid
        if resource is not None:
            request.resource = resource
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/CreateResource",
            request,
            Resource,
        )

    async def find_resources(
        self, *, client_uuid: str = "", filter: Optional["ResourceFilter"] = None
    ) -> FindResourcesResponse:
        """Find resource IDs given criteria."""

        request = FindResourcesRequest()
        request.client_uuid = client_uuid
        if filter is not None:
            request.filter = filter

        return await self._unary_unary(
            "/inventory.v1.InventoryService/FindResources",
            request,
            FindResourcesResponse,
        )

    async def get_resource(
        self, *, client_uuid: str = "", resource_id: str = "", tenant_id: str = ""
    ) -> GetResourceResponse:
        """Get information about a single resource given resource ID."""

        request = GetResourceRequest()
        request.client_uuid = client_uuid
        request.resource_id = resource_id
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/GetResource",
            request,
            GetResourceResponse,
        )

    async def update_resource(
        self,
        *,
        client_uuid: str = "",
        resource_id: str = "",
        field_mask: Optional[protobuf.FieldMask] = None,
        resource: Optional["Resource"] = None,
        tenant_id: str = "",
    ) -> Resource:
        """
        Update a resource with a given ID, returning the updated resource. If
        the update results in a hard-delete, the resource is returned in its
        last state before deletion. Returns UNKNOWN_CLIENT error if the UUID is
        not known. See SubscribeEvents.
        """

        request = UpdateResourceRequest()
        request.client_uuid = client_uuid
        request.resource_id = resource_id
        if field_mask is not None:
            request.field_mask = field_mask
        if resource is not None:
            request.resource = resource
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/UpdateResource",
            request,
            Resource,
        )

    async def delete_resource(
        self, *, client_uuid: str = "", resource_id: str = "", tenant_id: str = ""
    ) -> DeleteResourceResponse:
        """
        Delete a resource with a given ID. Returns UNKNOWN_CLIENT error if the
        UUID is not known. See SubscribeEvents.
        """

        request = DeleteResourceRequest()
        request.client_uuid = client_uuid
        request.resource_id = resource_id
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/DeleteResource",
            request,
            DeleteResourceResponse,
        )

    async def list_resources(
        self, *, client_uuid: str = "", filter: Optional["ResourceFilter"] = None
    ) -> ListResourcesResponse:
        """List resources given a criteria."""

        request = ListResourcesRequest()
        request.client_uuid = client_uuid
        if filter is not None:
            request.filter = filter

        return await self._unary_unary(
            "/inventory.v1.InventoryService/ListResources",
            request,
            ListResourcesResponse,
        )

    async def list_inherited_telemetry_profiles(
        self,
        *,
        client_uuid: str = "",
        inherit_by: Optional["ListInheritedTelemetryProfilesRequestInheritBy"] = None,
        filter: Optional["ResourceFilter"] = None,
        tenant_id: str = "",
    ) -> ListInheritedTelemetryProfilesResponse:
        """
        Custom RPC for Telemetry: Lists the inherited telemetry given a site,
        instance or region ID.
        """

        request = ListInheritedTelemetryProfilesRequest()
        request.client_uuid = client_uuid
        if inherit_by is not None:
            request.inherit_by = inherit_by
        if filter is not None:
            request.filter = filter
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/ListInheritedTelemetryProfiles",
            request,
            ListInheritedTelemetryProfilesResponse,
        )

    async def get_tree_hierarchy(
        self,
        *,
        client_uuid: str = "",
        filter: List[str] = [],
        descending: bool = False,
        tenant_id: str = "",
    ) -> GetTreeHierarchyResponse:
        """
        Returns the upstream tree hierarchy given the resource ID in the
        request. The response contains a list of adjacent nodes, from which the
        tree can be reconstructed.
        """

        request = GetTreeHierarchyRequest()
        request.client_uuid = client_uuid
        request.filter = filter
        request.descending = descending
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/GetTreeHierarchy",
            request,
            GetTreeHierarchyResponse,
        )

    async def get_sites_per_region(
        self, *, client_uuid: str = "", filter: List[str] = [], tenant_id: str = ""
    ) -> GetSitesPerRegionResponse:
        """
        Returns a list of the number of sites per region ID given the list of
        region IDs in the request. The response contains a list of objects with
        a region ID associated to the total amount of sites under it. The sites
        under a region account for all the sites under its child regions
        recursively, respecting the max-depth of parent relationships among
        regions.
        """

        request = GetSitesPerRegionRequest()
        request.client_uuid = client_uuid
        request.filter = filter
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/GetSitesPerRegion",
            request,
            GetSitesPerRegionResponse,
        )

    async def delete_all_resources(
        self,
        *,
        client_uuid: str = "",
        resource_kind: "ResourceKind" = 0,
        enforce: bool = False,
        tenant_id: str = "",
    ) -> DeleteAllResourcesResponse:
        """Deletes all resources of given kind for tenant."""

        request = DeleteAllResourcesRequest()
        request.client_uuid = client_uuid
        request.resource_kind = resource_kind
        request.enforce = enforce
        request.tenant_id = tenant_id

        return await self._unary_unary(
            "/inventory.v1.InventoryService/DeleteAllResources",
            request,
            DeleteAllResourcesResponse,
        )
